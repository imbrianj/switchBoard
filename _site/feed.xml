<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="http://localhost:4000/switchBoard/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/switchBoard/" rel="alternate" type="text/html" /><updated>2018-12-15T11:11:26-08:00</updated><id>http://localhost:4000/switchBoard/</id><title type="html">SwitchBoard Home Automation</title><subtitle>Node.js home automation system with machine learning</subtitle><entry><title type="html">D-Link Camera</title><link href="http://localhost:4000/switchBoard/DLink-Camera/" rel="alternate" type="text/html" title="D-Link Camera" /><published>2018-12-15T00:00:00-08:00</published><updated>2018-12-15T00:00:00-08:00</updated><id>http://localhost:4000/switchBoard/DLink%20Camera</id><content type="html" xml:base="http://localhost:4000/switchBoard/DLink-Camera/">&lt;p&gt;After my &lt;a href=&quot;https://imbrianj.github.io/switchBoard/Camera-Woes/&quot;&gt;Foscam camera gave up&lt;/a&gt;, I was on the lookout for a new camera I could use with SwitchBoard.  It needed to be a pan / tilt camera, so I could make sure it was staring at a wall when not armed (because &lt;a href=&quot;http://127.0.0.1:4000/switchBoard/So,-What-About-Privacy/&quot;&gt;I’m paranoid&lt;/a&gt;).  It needed to support MJPEG or some other means of rendering live video to a wide set of browsers without a plugin.  And, finally, it needed to not be crappy.  Something built by a reputable manufacturer that was easily found.  I landed on the D-Link DCS-5222LB.  It can be had for about &lt;a href=&quot;https://smile.amazon.com/dp/B008915L2O&quot;&gt;$85 right now on Amazon&lt;/a&gt; and other models that may or may not work can be found for less.&lt;/p&gt;

&lt;p&gt;As this camera requires Basic Auth for every request, you &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=303046#c54&quot;&gt;cannot embed&lt;/a&gt; the preview image directly into a webpage within most browsers now’a’days.  Makes sense.  As Foscam allowed auth credentials to be passed as simple GET parameters, I relied on that authentication method for Foscam preview images.  The thinking there is that we’re on a trusted internal network - it wasn’t a major concern.  The documentation should make it very clear that Foscam was insecure in this regard so one could make an educated decision on the security trade-offs.  Not so with the D-Link.  Which is fine.  I’ve set up a new STREAM command type that basically listens to an endpoint (that can be properly authed) and just writes those bytes straight to the client without any computation at all.  It doesn’t seem to be a major CPU burden - just a bit on bandwidth.  But if the SwitchBoard instance is on the same fast network as the camera, it’s probably nothing to worry about.  So now you can preview the D-Link camera and not expose any credentials.  Great.  I was considering updating the Foscam controller to support this as well, but seeing as they no longer sell cameras that support MJEPG, I don’t think I’ll bother.  The Foscam controller is probably pretty safely considered unsupported now.&lt;/p&gt;

&lt;p&gt;I had built SwitchBoard to specifically use the Raspberry Pi.  It’s a reasonably well equipped, low power, inexpensive and well known host so it fits the bill pretty well.  With multiple cameras, you may find it lacking in the CPU department.  I’m able to use dLinkCameraDvr with the lowest resolution and lowest quality for a single camera and the Raspberry Pi is able to mostly make use of it.  Increase quality or add another camera and the results are largely unusable.  I’m thinking now how to best handle this.  One option is to just buy a better performing SoC - but that strays from my original intent.  Another option is to have an instance of SwitchBoard running on another Raspberry Pi for each camera to record - and probably have some kind of network mount to share the videos / thumbnails with the instance running the primary interface.  This would solve most of the issues, most of the software is already set up for this and I have the extra device.&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="device" /><category term="home automation" /><summary type="html">After my Foscam camera gave up, I was on the lookout for a new camera I could use with SwitchBoard. It needed to be a pan / tilt camera, so I could make sure it was staring at a wall when not armed (because I’m paranoid). It needed to support MJPEG or some other means of rendering live video to a wide set of browsers without a plugin. And, finally, it needed to not be crappy. Something built by a reputable manufacturer that was easily found. I landed on the D-Link DCS-5222LB. It can be had for about $85 right now on Amazon and other models that may or may not work can be found for less.</summary></entry><entry><title type="html">Camera Woes</title><link href="http://localhost:4000/switchBoard/Camera-Woes/" rel="alternate" type="text/html" title="Camera Woes" /><published>2018-10-12T00:00:00-07:00</published><updated>2018-10-12T00:00:00-07:00</updated><id>http://localhost:4000/switchBoard/Camera%20Woes</id><content type="html" xml:base="http://localhost:4000/switchBoard/Camera-Woes/">&lt;p&gt;The other week, the Foscam I’d been using for a number of years blew up.  It had an audible “pop” as something inside decided to give up.  I went on the hunt for a camera I could replace it with and found it to be pretty difficult.  Most are now using h.264 since it has much better quality than mjpeg - but it comes at the cost of compatibility.  For web stuff, mjpeg is pretty tough to beat, as long as you don’t care too too much about the quality - so I figured that was what I was aiming for.  Foscam - and their new company Amcrest - both have switched over entirely to h.264.  So that’s not a great option for this use-case.&lt;/p&gt;

&lt;p&gt;I’ve opted to buy a couple D-Link DCS-5222L HD cameras.  They have very similar specs to the old Foscam, but the software seems more refined.  I have some basic controllers set up to pan / tilt / go to preset locations but haven’t hooked up streaming, DVR or anything else yet.&lt;/p&gt;

&lt;p&gt;They have their own integration problems, though.  Chrome has removed the ability to embed Basic Auth assets.  This means that I cannot directly reference the D-Link camera feed to the browser in the SwitchBoard interface.  As I can get the Basic Auth from node, I’m intending to pipe that output to a locale endpoint on the SwitchBoard instance.  We’ll see if that works and what the performance impact will be.  The interface already lazy loads and unloads dynamic images - so if you’re not viewing the image, it should automatically cease streaming.&lt;/p&gt;

&lt;p&gt;If you’re shopping for a camera, I’d hold off on a recommendation from me here, but these seem promising.  I just wish they allowed the authentication to be sent via GET params.  Even if done optionally, it’d widen the usefulness for when run on a secured network.  If the piping works efficiently enough, it’s just as well - it’ll help conceal credentials to the interface.  While that isn’t a value-add for me, maybe it is for someone else.&lt;/p&gt;

&lt;p&gt;I also intend to start picking at Lutron integration again - but no promises on delivering something usable.&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="device" /><category term="home automation" /><summary type="html">The other week, the Foscam I’d been using for a number of years blew up. It had an audible “pop” as something inside decided to give up. I went on the hunt for a camera I could replace it with and found it to be pretty difficult. Most are now using h.264 since it has much better quality than mjpeg - but it comes at the cost of compatibility. For web stuff, mjpeg is pretty tough to beat, as long as you don’t care too too much about the quality - so I figured that was what I was aiming for. Foscam - and their new company Amcrest - both have switched over entirely to h.264. So that’s not a great option for this use-case.</summary></entry><entry><title type="html">Day Categories</title><link href="http://localhost:4000/switchBoard/Day-Categories/" rel="alternate" type="text/html" title="Day Categories" /><published>2018-08-02T00:00:00-07:00</published><updated>2018-08-02T00:00:00-07:00</updated><id>http://localhost:4000/switchBoard/Day%20Categories</id><content type="html" xml:base="http://localhost:4000/switchBoard/Day-Categories/">&lt;p&gt;I’ve been making a lot of use from the machine learning aspects of SwitchBoard lately.  It’s been pretty handy (and sometimes borderline spooky) when a light turns on the second you think you want it on, without any explicit interactions at all.  While the good outweigh the bad actions by a fair margin, there have been a few notable “oh, that’s not good” moments.  Specifically when someone is asleep and a light turns on because Sunday is a weekend, I stay up late on weekends, and it’s 11:30pm…a work night.  Not good.&lt;/p&gt;

&lt;p&gt;Clearly, I needed to add some additional buckets of data to sort events into so that it’s clear that my Friday and Saturday nights, where I stay up late, are different than Sunday nights, where I go to bed at a reasonable hour.  Or what about those that work schedules that have their days off on days other than weekends?  I’ve just committed code to go from simple weekday/weekend time categories to one for each day of the week.&lt;/p&gt;

&lt;p&gt;All good, right?  Well, there are some drawbacks.  One big caveat is that, if you were using the machine learning up till now, you’ll have to rename your cache/db/processed.json file and restart SwitchBoard to let it generate the new processed file - which can take quite a while (on a Pi, maybe measured in hours depending on the amount of data).  I have about 10 months of data being processed.  The resulting file has roughly tripled in size.  As this file is stored in memory, you can expect about ~20MB of additional memory to be consumed if you consider my usage a yardstick.  Beyond this, since there are more discrete time categories in which events may be logged, you’ll need up to 5x more data logged before actions will be reliably learned.  I may tweak the default config settings to be a bit more loose as it begins to learn, allowing people to see actions sooner, even if they’re maybe not nearly as accurate as we’d like.&lt;/p&gt;

&lt;p&gt;This is just an experiment to see if the costs outweigh the benefits.  I expect this to be a positive change, given the accuracy and memory footprint.  The time to learn has increased a bunch, but I think the long-term benefits are pretty good.  While I would like to use both - broader categories for the early days of learning and the more granular as it begins to learn more about your patterns, I think a clean solution that doesn’t unnecessarily consume too much memory probably isn’t worth the effort.&lt;/p&gt;

&lt;p&gt;Once I think I’ve found the sweet-spot for the config defaults, I’ll roll out npm package 0.3.0.&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="device" /><category term="machine learning" /><category term="home automation" /><category term="gerty" /><summary type="html">I’ve been making a lot of use from the machine learning aspects of SwitchBoard lately. It’s been pretty handy (and sometimes borderline spooky) when a light turns on the second you think you want it on, without any explicit interactions at all. While the good outweigh the bad actions by a fair margin, there have been a few notable “oh, that’s not good” moments. Specifically when someone is asleep and a light turns on because Sunday is a weekend, I stay up late on weekends, and it’s 11:30pm…a work night. Not good.</summary></entry><entry><title type="html">Current Status</title><link href="http://localhost:4000/switchBoard/Current-Status/" rel="alternate" type="text/html" title="Current Status" /><published>2018-06-25T00:00:00-07:00</published><updated>2018-06-25T00:00:00-07:00</updated><id>http://localhost:4000/switchBoard/Current%20Status</id><content type="html" xml:base="http://localhost:4000/switchBoard/Current-Status/">&lt;p&gt;I haven’t posted anything for a while, so thought I’d give a quick update.  A lot of the latest changes are pretty limited to just bug fixes and updating of dependencies.  Much of my time is now spent trying to get the machine learning parameters tweaked so they are the most effective and minimizing inconvenient actions.  So far, I’ve been pretty happy with how things are working - but trying to teach new behaviors takes a bit more time than I’d like.  Otherwise, I’ve just been trying to address any of the little bugs that crop up.&lt;/p&gt;

&lt;p&gt;I tag explicit versions for all dependencies so I’m able to see what affect each upgrade has.  I’ve recently upgraded &lt;code class=&quot;highlighter-rouge&quot;&gt;grunt&lt;/code&gt; from 1.0.2 to 1.0.3.  With that upgrade, some of it’s dependencies apparently no longer work with very old version of Node.js.  As such, official support has been dropped for Node.js 0.12 and below as well as io.js.  This shouldn’t really bother most anyone as these are quite old - but, if for whatever reason, you do need to run on a very old instance, you may still find luck with &lt;code class=&quot;highlighter-rouge&quot;&gt;npm install --production&lt;/code&gt; that should cut out much of the overhead and dependencies with no day-to-day impact.  You just won’t be able to run tasks or tests locally.&lt;/p&gt;

&lt;p&gt;I have begun work on Lutron support, but I haven’t found the time to finish it up.  I’ve been able to read device state, but have had some difficulties in figuring out how to write to devices (ie: I can see a dimmer switch is at 50%, but I’m unable to set it to 75%).&lt;/p&gt;

&lt;p&gt;Things I have in some state of development (with no promises of completion) are Lutron, asking simple questions (“do I need an umbrella?”, “who is home?”, “when is sunrise?”, etc) and continuing bug fixes and minor tweaks.&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="dependencies" /><summary type="html">I haven’t posted anything for a while, so thought I’d give a quick update. A lot of the latest changes are pretty limited to just bug fixes and updating of dependencies. Much of my time is now spent trying to get the machine learning parameters tweaked so they are the most effective and minimizing inconvenient actions. So far, I’ve been pretty happy with how things are working - but trying to teach new behaviors takes a bit more time than I’d like. Otherwise, I’ve just been trying to address any of the little bugs that crop up.</summary></entry><entry><title type="html">Another One Bites The Dust</title><link href="http://localhost:4000/switchBoard/Another-One-Bites-The-Dust/" rel="alternate" type="text/html" title="Another One Bites The Dust" /><published>2018-02-26T00:00:00-08:00</published><updated>2018-02-26T00:00:00-08:00</updated><id>http://localhost:4000/switchBoard/Another%20One%20Bites%20The%20Dust</id><content type="html" xml:base="http://localhost:4000/switchBoard/Another-One-Bites-The-Dust/">&lt;p&gt;I’ll be honest.  I’ve got a touch of paranoia.  With everyone with their newfangled Google Alexas and whatnot, I just want to go back to a simple home automation like my forebears built with their bare hands.  With that, I’ve lately been spending more time trying to minimize outside exposure.  This comes in a few areas: creating devices that don’t require APIs so I can, for example, ween off SmartThings.  Although SmartThings is a great product for what it is, I think it’s fair to say that if you’re compiling node.js on your Pi in pursuit of a home automation system - it might not be exactly what you’re looking for.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/switchBoard/images/dependencies/dependencies.png&quot; alt=&quot;Very few remaining dependencies.&quot; title=&quot;Very few remaining dependencies&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Secondly, I’m trying to reduce dependencies.  Some, near as I can tell, are pretty unavoidable.  If you install your modules with &lt;code class=&quot;highlighter-rouge&quot;&gt;npm i --production&lt;/code&gt;, you’ll install only two immediate dependencies, with a total of ten total dependencies.  As node.js does not natively allow XML parsing, &lt;a href=&quot;https://www.npmjs.com/package/xml2js&quot;&gt;xml2js&lt;/a&gt; is used for RSS / Atom feeds and Roku support.  &lt;a href=&quot;https://www.npmjs.com/package/websocket&quot;&gt;Websocket&lt;/a&gt; is used for…well, connecting via websockets.&lt;/p&gt;

&lt;p&gt;I had been using &lt;a href=&quot;https://www.npmjs.com/package/request&quot;&gt;request&lt;/a&gt; but removed it as it wasn’t a huge burden to bake in that functionality, it had a lot of dependencies at 57 and had a (very minor) security issue with a dependency that took long enough to address, it was easier for me to just axe the whole thing.&lt;/p&gt;

&lt;p&gt;SwitchBoard is written to be simple.  As my use-case isn’t terribly advanced, it’s often easy enough to just write my own little bits of code to get around having a relatively oversized dependency.  While this wouldn’t fly if I were being paid to do this work; as a hobby, I find it more interesting this way.  This is in no way suggesting that my own code is more secure or better than those that it depends on - but at least this way, if issues are found, I’m able to address the code myself.  Like grandpa used to do.&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="dependencies" /><category term="security" /><summary type="html">I’ll be honest. I’ve got a touch of paranoia. With everyone with their newfangled Google Alexas and whatnot, I just want to go back to a simple home automation like my forebears built with their bare hands. With that, I’ve lately been spending more time trying to minimize outside exposure. This comes in a few areas: creating devices that don’t require APIs so I can, for example, ween off SmartThings. Although SmartThings is a great product for what it is, I think it’s fair to say that if you’re compiling node.js on your Pi in pursuit of a home automation system - it might not be exactly what you’re looking for.</summary></entry><entry><title type="html">Seeking Precision</title><link href="http://localhost:4000/switchBoard/Seeking-Precision/" rel="alternate" type="text/html" title="Seeking Precision" /><published>2018-02-04T00:00:00-08:00</published><updated>2018-02-04T00:00:00-08:00</updated><id>http://localhost:4000/switchBoard/Seeking%20Precision</id><content type="html" xml:base="http://localhost:4000/switchBoard/Seeking-Precision/">&lt;p&gt;Running a bunch of data on a low power system with limited disc space is an exercise in balance.  When I first started building the machine learning component of SwitchBoard, I had made the assumption that four time categories (dawn, morning, afternoon, evening) would be sufficient to find some usefulness.  And this was true.  But, in an effort to make it more precise (thus, more useful), I’ve decided to experiment with upping the time categories to six (midnight, dawn, morning, afternoon, evening, night).  Since behaviors in your home are tied closely to time - you likely don’t have your kitchen light on as much at 3am than you would at 5pm - I’m going to try and see if the predictions are more accurate.&lt;/p&gt;

&lt;p&gt;This, however, comes at the cost of data required for learning.  We now break things up into 6 time categories and 2 day categories (for a total of 12 discreet categories).  By default, we require 100 instances of any event for the system to even acknowledge it as a possible trigger of an action.  I may lower this now that we have more discreet time categories, since it may take a month or longer to see any results of a freshly configured system.  But this begs the question: would you rather see a system that’s less accurate, but quietly learns for a relatively short time - or one that is more accurate, but takes longer to learn?  I suspect that the answer to this will differ greatly from person to person.  Thankfully, editing your config file’s &lt;code class=&quot;highlighter-rouge&quot;&gt;ai.minimumThreshold&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ai.confidence&lt;/code&gt;, you can change these parameters at will.  They will require a restart, but nothing major.  If you do play around with these values and find something that works well, let me know and I can readjust the default values.&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="device" /><category term="machine learning" /><category term="home automation" /><category term="gerty" /><summary type="html">Running a bunch of data on a low power system with limited disc space is an exercise in balance. When I first started building the machine learning component of SwitchBoard, I had made the assumption that four time categories (dawn, morning, afternoon, evening) would be sufficient to find some usefulness. And this was true. But, in an effort to make it more precise (thus, more useful), I’ve decided to experiment with upping the time categories to six (midnight, dawn, morning, afternoon, evening, night). Since behaviors in your home are tied closely to time - you likely don’t have your kitchen light on as much at 3am than you would at 5pm - I’m going to try and see if the predictions are more accurate.</summary></entry><entry><title type="html">Machine Learning Home Automation Update</title><link href="http://localhost:4000/switchBoard/Machine-Learning-Home-Automation-Update/" rel="alternate" type="text/html" title="Machine Learning Home Automation Update" /><published>2018-01-24T00:00:00-08:00</published><updated>2018-01-24T00:00:00-08:00</updated><id>http://localhost:4000/switchBoard/Machine%20Learning%20Home%20Automation%20Update</id><content type="html" xml:base="http://localhost:4000/switchBoard/Machine-Learning-Home-Automation-Update/">&lt;p&gt;I’d recently &lt;a href=&quot;https://imbrianj.github.io/switchBoard/The-Training-Wheels-Are-Off!/&quot;&gt;taken the training wheels off&lt;/a&gt; my machine learning home automation system.  For quite a while, it was quietly collecting data and logging when it thought it had high enough confidence to actually take action.  Since that time, I’ve made some changes to the way things are executed - but they’ve all been relatively small changes.  I’ve also made some observations I thought might be worth sharing.&lt;/p&gt;

&lt;p&gt;At first, actions would be logged in the Gerty dialog, but I might not notice them right away, making correcting the action more difficult.  If Gerty triggers an action, you have one minute to correct that action before it then takes the new state as the desired state.  If it does something you do not like, you have a minute to correct it, allowing it to learn what is preferred.  Ignoring it, the action will be reinforced.  I’ve since added a bike bell sound, so I hear a chime when it takes action.  This is configurable, but I’ve found it helpful while I’m still learning what it wants to be doing.  Just a quick “hey, I just did something!”&lt;/p&gt;

&lt;p&gt;A few interesting anecdotes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I woke up late at night and went to the kitchen to grab a drink of water.  The light turned on automatically for me.  I could have done without it, but - hey, thanks!&lt;/li&gt;
  &lt;li&gt;Late at night, I was getting ready for bed and the bedroom lights turned off.  I would have hit the switch a minute later, but - sure, I’ll call it good now.&lt;/li&gt;
  &lt;li&gt;Several times, when I was staying up later than usual watching TV, the lights would start turning off.  You’re right - I should probably finish the episode tomorrow.&lt;/li&gt;
  &lt;li&gt;When I enter my office, depending on the day and time, the light typically turns on by itself.&lt;/li&gt;
  &lt;li&gt;A few other instances of “huh…I guess that’s nice”.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These all sound positive - and most are.  At worst, they’re typically of neutral appeal (sure, the light turned off - that’s fine.  I’ll leave it off).  There have been a few instances where the triggered behavior was not as desired.  I have a light in my dining room I don’t typically use - so when I was actually using it, it would want to turn off every 30 minutes (the event cooldown time).  I’ve upped this to 60 minutes and I’ve found it to be decent.  I would say that roughly 5% of the actions it takes are undesirable.  On a typical day, it executes 5 - 10 actions on it’s own.  This could be increased at the cost of accuracy, but I’m still trying to find the sweet spot.&lt;/p&gt;

&lt;p&gt;A large number of the action triggers are simple temperature measurements.  From there, it finds interesting relationships.  It’s discovered that my office light is nearly always on when my laundry room is 70°.  When these actions happen, they’re usually not bad.  These temperature measurements are probably far more useful based on how the events are categorized.  Each event that’s learned is bucketed into either a weekday or weekend.  From there, it’s subcategorized into a time block (dawn, morning, afternoon, evening).  If an event is triggered in the evening, it will not add any weight to those considered for the morning.  These temperature readings are likely finding the overall averages “during the weekday, in the mornings - this light is usually off.” - as opposed to considering what the temperature actually is.  Certainly the temperature itself is a factor in the equation, but I suspect it plays only a minor part.  One could add more granularity by subdividing these categories further - but it would come at the cost of either having to collect vastly more data (since each bucket must hit a threshold of events before being deemed reliable).  I think the current categories are probably fine - but I may revisit this in the future, as I have more data collected.&lt;/p&gt;

&lt;p&gt;All in all, I’ve found the machine learning actions to be interesting.  Not super useful, but certainly a fun novelty to play with.  That being said, I’ve been happy with it and intend to continue experimenting.&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="device" /><category term="machine learning" /><category term="home automation" /><category term="gerty" /><summary type="html">I’d recently taken the training wheels off my machine learning home automation system. For quite a while, it was quietly collecting data and logging when it thought it had high enough confidence to actually take action. Since that time, I’ve made some changes to the way things are executed - but they’ve all been relatively small changes. I’ve also made some observations I thought might be worth sharing.</summary></entry><entry><title type="html">The Training Wheels Are Off!</title><link href="http://localhost:4000/switchBoard/The-Training-Wheels-Are-Off!/" rel="alternate" type="text/html" title="The Training Wheels Are Off!" /><published>2018-01-10T00:00:00-08:00</published><updated>2018-01-10T00:00:00-08:00</updated><id>http://localhost:4000/switchBoard/The%20Training%20Wheels%20Are%20Off!</id><content type="html" xml:base="http://localhost:4000/switchBoard/The-Training-Wheels-Are-Off!/">&lt;p&gt;I had &lt;a href=&quot;https://imbrianj.github.io/switchBoard/Machine-(Slowly)-Learning/&quot;&gt;posted before&lt;/a&gt; about the Machine Learning incorporated into SwitchBoard.  At that time, I was still collecting data and wasn’t able to fully test every part of the functionality.  I now have that data.&lt;/p&gt;

&lt;p&gt;I’ve been making improvements to the Machine Learning - slight tweaks to how events are recorded and changes to the logic in how different events are considered.&lt;/p&gt;

&lt;p&gt;One change to database records was the use of milliseconds instead of seconds.  While this will inflate data storage a bit, it makes a common baseline that can more intuitively be used throughout the codebase as this is natively acquired via &lt;code class=&quot;highlighter-rouge&quot;&gt;new Date.getTime()&lt;/code&gt;.  If you have a bunch of recorded events and would like to update it to the new format, let me know and I can post a script I used.  It’ll just run through all recorded time values and multiply them by 1000.  Worth noting: there is no current loss of functionality if you do not migrate.  Most all of the time records are done for features that have not yet been implemented.&lt;/p&gt;

&lt;p&gt;Once the major bugs had been ironed out, I found the actions taken by SwitchBoard to be few, but not incorrect.  It has potential to be helpful, but I am still not convinced it will grow to be anything more than a novelty.  I will continue to tweak the parameters and build packages once I find something that’s as usable as possible.&lt;/p&gt;

&lt;p&gt;Some interesting observations I’ve seen are actions taken that were unexpected.  I was notified that “Because of subdevice-state-temp-Office-68, I’m 83% sure you want the Living Room Switch off”.  While I didn’t even notice that the Living Room Switch was turned off (meaning it was valuable in saving that electricity) - it was an unexpected relationship that the office temperature was 68° and it thought that was related to the Living Room Switch at all - it is likelier chalked up to dumb luck than any profound insights gained.  Regardless, it’s interesting to see it behave - and if it ever does misbehave, it’s simple enough to correct it.  By simply countering whatever action it had committed within the (configurable) one minute grace period, it will automatically reinforce the desired behaviors.&lt;/p&gt;

&lt;p&gt;I’ve added a ton more logging data, so you should be able to at least get an idea of why certain actions are or are not taken.  You may see messages in the log like:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AI: Ignoring Living Room Lamp since it recently changed state.
AI: Already set, but 97% confident Closet Lamp should be off.
AI: Only 66% confident Humidifier should be off.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This illustrates some of the five special conditions that the machine learning can derive:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It’s a desired action.  Execute on it.&lt;/li&gt;
  &lt;li&gt;It’s a desired action.  But the current state matches the desired state, so there’s nothing to be done.  Ignore it.&lt;/li&gt;
  &lt;li&gt;It may or may not be a desired action - the device has undergone a change within a certain amount of (configurable) time.  Ignore it.  If you and your house have a disagreement as to what is a desirable state of any devices, this is the tie-breaker.  If you say “I want this lamp off”, SwitchBoard cannot immediately disagree and turn it back on.&lt;/li&gt;
  &lt;li&gt;It is not a desired action as the confidence level has not surpassed the configurable threshold.  Ignore it.&lt;/li&gt;
  &lt;li&gt;It’s a read-only device (such as a motion sensor, temperature sensor) - so no action can be done to the device.  Ignore it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This solution is, admittedly, very simplistic.  It’s a simple hash table of single events, mapped to many device states.  For a real breakthrough, I think compound conditions will need to be done.  If a motion sensor goes off AND my presence sensor is not active, the outcome could be very different than if I were home.  I’m trying to keep things simple for now, allowing me to change things quickly and not being overly committed into something overwhelming.&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="device" /><category term="machine learning" /><category term="home automation" /><category term="gerty" /><summary type="html">I had posted before about the Machine Learning incorporated into SwitchBoard. At that time, I was still collecting data and wasn’t able to fully test every part of the functionality. I now have that data.</summary></entry><entry><title type="html">Enabling Voice Commands On Android</title><link href="http://localhost:4000/switchBoard/Enabling-Voice-Commands-On-Android/" rel="alternate" type="text/html" title="Enabling Voice Commands On Android" /><published>2018-01-08T00:00:00-08:00</published><updated>2018-01-08T00:00:00-08:00</updated><id>http://localhost:4000/switchBoard/Enabling%20Voice%20Commands%20On%20Android</id><content type="html" xml:base="http://localhost:4000/switchBoard/Enabling-Voice-Commands-On-Android/">&lt;p&gt;I’m not a big fan of “always on” smart speakers such as Google Home, Alexa, etc.  To me, it’s just too creepy to have a speaker closely tied to the Internet, built by companies with a vested interest in knowing more about you that’s always on and listening.  If you’re paranoid like me, here are some steps to get on-demand (ie: requiring a button press) voice recognition on your smart phone that will work with SwitchBoard.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;You’ll need &lt;a href=&quot;https://play.google.com/store/apps/details?id=net.dinglisch.android.taskerm&quot;&gt;Tasker for Android&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Open Tasker and go to the “Tasks” tab.&lt;/li&gt;
  &lt;li&gt;Click the “+” in the bottom right to create a new task.  Enter “Voice” (or something) as the name.&lt;/li&gt;
  &lt;li&gt;Inside the “Voice” task, click the “+” to create a new &lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;.
&lt;span class=&quot;images&quot;&gt;
  &lt;a href=&quot;/switchBoard/images/voice/selectAction.png&quot;&gt;&lt;img src=&quot;/switchBoard/images/voice/selectAction.png&quot; alt=&quot;List of all Action Categories&quot; title=&quot;List of all Action Categories&quot; /&gt;&lt;/a&gt;
&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;Click &lt;code class=&quot;highlighter-rouge&quot;&gt;Input&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;Get Voice&lt;/code&gt;.  You can leave the settings for &lt;code class=&quot;highlighter-rouge&quot;&gt;Get Voice&lt;/code&gt; default.
&lt;span class=&quot;images&quot;&gt;
  &lt;a href=&quot;/switchBoard/images/voice/inputActions.png&quot;&gt;&lt;img src=&quot;/switchBoard/images/voice/inputActions.png&quot; alt=&quot;Creating a new &amp;quot;Get Voice&amp;quot; Action&quot; title=&quot;Creating a new &amp;quot;Get Voice&amp;quot; Action&quot; /&gt;&lt;/a&gt;
  &lt;a href=&quot;/switchBoard/images/voice/voiceConfig.png&quot;&gt;&lt;img src=&quot;/switchBoard/images/voice/voiceConfig.png&quot; alt=&quot;My settings for Get Voice Action&quot; title=&quot;My settings for Get Voice Action&quot; /&gt;&lt;/a&gt;
&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;Go back to the “Voice” task and click the “+” again to create another new &lt;code class=&quot;highlighter-rouge&quot;&gt;Action&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;This time, click &lt;code class=&quot;highlighter-rouge&quot;&gt;Net&lt;/code&gt;, then &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP Get&lt;/code&gt;.
&lt;span class=&quot;images&quot;&gt;
  &lt;a href=&quot;/switchBoard/images/voice/networkActions.png&quot;&gt;&lt;img src=&quot;/switchBoard/images/voice/networkActions.png&quot; alt=&quot;Creating a new &amp;quot;HTTP GET&amp;quot; Action&quot; title=&quot;Creating a new &amp;quot;HTTP GET&amp;quot; Action&quot; /&gt;&lt;/a&gt;
&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;Inside the settings for the network action, specify your &lt;code class=&quot;highlighter-rouge&quot;&gt;Server:Port&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;For the &lt;code class=&quot;highlighter-rouge&quot;&gt;Path&lt;/code&gt;, enter: &lt;code class=&quot;highlighter-rouge&quot;&gt;?gerty=text-%VOICE&lt;/code&gt;.  Note, if you’ve changed Gerty’s deviceId from the default in SwitchBoard, change that here to match.
&lt;span class=&quot;images&quot;&gt;
  &lt;a href=&quot;/switchBoard/images/voice/networkConfig.png&quot;&gt;&lt;img src=&quot;/switchBoard/images/voice/networkConfig.png&quot; alt=&quot;My settings for HTTP GET Action&quot; title=&quot;My settings for HTTP GET Action&quot; /&gt;&lt;/a&gt;
&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;In the main “Voice” task page, you’ll see an icon in the bottom center.  Clicking this allows you to associate an icon.  I had chosen &lt;code class=&quot;highlighter-rouge&quot;&gt;Material&lt;/code&gt; and searched &lt;code class=&quot;highlighter-rouge&quot;&gt;Voice&lt;/code&gt;.
&lt;span class=&quot;images&quot;&gt;
  &lt;a href=&quot;/switchBoard/images/voice/iconChooser.png&quot;&gt;&lt;img src=&quot;/switchBoard/images/voice/iconChooser.png&quot; alt=&quot;Searching for &amp;quot;Voice&amp;quot; within the Material icon list&quot; title=&quot;Searching for &amp;quot;Voice&amp;quot; within the Material icon list&quot; /&gt;&lt;/a&gt;
  &lt;a href=&quot;/switchBoard/images/voice/taskView.png&quot;&gt;&lt;img src=&quot;/switchBoard/images/voice/taskView.png&quot; alt=&quot;View of completed Task&quot; title=&quot;View of completed Task&quot; /&gt;&lt;/a&gt;
&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;Back at the home screen of your phone, long press on an empty space.  When the menu pops up, selected &lt;code class=&quot;highlighter-rouge&quot;&gt;Widgets&lt;/code&gt;.  Scroll down to &lt;code class=&quot;highlighter-rouge&quot;&gt;Tasker&lt;/code&gt; and hold the &lt;code class=&quot;highlighter-rouge&quot;&gt;Task&lt;/code&gt; icon and drag it to your home screen.&lt;/li&gt;
  &lt;li&gt;In the &lt;code class=&quot;highlighter-rouge&quot;&gt;Task Selection&lt;/code&gt;, choose your new “Voice” task.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You should now have an icon on your home screen allowing you to quickly fire voice commands to SwitchBoard.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;images&quot;&gt;
  &lt;a href=&quot;/switchBoard/images/voice/voiceInput.png&quot;&gt;&lt;img src=&quot;/switchBoard/images/voice/voiceInput.png&quot; alt=&quot;Example of using Get Voice from a desktop icon&quot; title=&quot;Example of using Get Voice from a desktop icon&quot; /&gt;&lt;/a&gt;
&lt;/span&gt;&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="howto" /><category term="home automation" /><category term="gerty" /><category term="voice" /><category term="android" /><summary type="html">I’m not a big fan of “always on” smart speakers such as Google Home, Alexa, etc. To me, it’s just too creepy to have a speaker closely tied to the Internet, built by companies with a vested interest in knowing more about you that’s always on and listening. If you’re paranoid like me, here are some steps to get on-demand (ie: requiring a button press) voice recognition on your smart phone that will work with SwitchBoard.</summary></entry><entry><title type="html">So, What About Privacy?</title><link href="http://localhost:4000/switchBoard/So,-What-About-Privacy/" rel="alternate" type="text/html" title="So, What About Privacy?" /><published>2018-01-03T00:00:00-08:00</published><updated>2018-01-03T00:00:00-08:00</updated><id>http://localhost:4000/switchBoard/So,%20What%20About%20Privacy</id><content type="html" xml:base="http://localhost:4000/switchBoard/So,-What-About-Privacy/">&lt;p&gt;A big reason I build SwitchBoard is so I can do things the way I think they should be done.  I like having my data be within my walls as much as possible.  For external APIs, you often have little choice in rely on those outside data points, but if they’re varied, you at least lessen your exposure.  My personal setup consumes a decent number of APIs and no single one has any real useful bits - they’re tied together and the logic to act upon them remains within my network.  Maybe I’m paranoid, but that seems like a good default starting place when building something that deals with so much personal information.&lt;/p&gt;

&lt;h3 id=&quot;so-what-is-switchboard-doing-about-privacy&quot;&gt;So, what is SwitchBoard doing about privacy?&lt;/h3&gt;

&lt;p&gt;For one, I have no clue how many people use it.  I may be the only one.  For my development decisions, this seems like the safest assumption as it gives me the most leeway to build it how I think it should be built.  I don’t use any tracking metrics aside from those that are unavoidable (Github Insights, NPM downloads, etc).  This blog doesn’t use Google Analytics.  Tracking creeps me out.&lt;/p&gt;

&lt;p&gt;It would be really helpful if I had functionality that, when an instance of SwitchBoard is installed, it would send data to me letting me know it was installed and with which devices, so I could focus efforts.  But that would go against a big part of why I started the project.  So I don’t.  If there’s a crash, it’s not reported to me.  I depend on people reporting issues to me.  It’s possible that, in the future, I may create an &lt;em&gt;opt-in&lt;/em&gt; special pseudo-device to allow users to send me some usage data, but it’t not currently planned.&lt;/p&gt;

&lt;p&gt;SwitchBoard, how I have it configured, logs a whole lot of data.  To aid in the machine learning, it builds up an index of patterns it can then act upon.  These are all A) completely optional and opt-in and B) held entirely locally.  Nothing is shared with the cloud or external parties that you have not opted into during the configuration process.  This also means that any “seed” files - like those that were popular with JS frameworks are a no-go.&lt;/p&gt;

&lt;p&gt;There are very few dependencies that are required to run SwitchBoard.  This mitigates unnecessary complication (in my opinion), exposure to external code vulnerabilities and keep SwitchBoard more aligned with the isolated anti-walled garden.  It’s generic JavaScript - use it as you please.&lt;/p&gt;

&lt;p&gt;Security and privacy have a fair bit of overlap.  Any APIs that support it, use SSL.  No credentials are sent to clients (except for Foscam - which is, unfortunately, required).&lt;/p&gt;

&lt;h3 id=&quot;what-is-switchboard-not-doing-about-privacy&quot;&gt;What is SwitchBoard not doing about privacy?&lt;/h3&gt;

&lt;p&gt;A huge part of the built in security depends on SwitchBoard being within a trusted network.  You should not poke holes in your firewall to expose SwitchBoard as that will circumvent that security it depends on.  If you are not within a trusted network, you open yourself up to allowing anyone within that network to have control of your devices.  For most home automation systems - where a single domicile is paired with a single home network - this seemed like a reasonable assumption to make.  If, however, this does not suit your needs, reach out and I can see about other possible solutions.&lt;/p&gt;

&lt;p&gt;Credentials are stored unencrypted on the server.  Those credentials are never shared to clients and only accessible via shell / ftp / local access - and via the device’s encrypted HTTPS commands.  While not ideal, it removes considerable overhead and complication that I personally feel is not of any real benefit to most users.  If you fear that someone may have access to your files on the server on which SwitchBoard is running, your config file will have passwords and personal information and will be at risk.&lt;/p&gt;

&lt;p&gt;With the assumption of the “single domicile is paired with a single home network” and automation system, there is no password protection or internal obfuscation.  I have not personally found the use case in which a person may be trusted to be on your network but should not be trusted to, say, adjust the thermostat or turn off lights.  If user settings or even generic password are something people are interested in, I can also look into that.&lt;/p&gt;

&lt;p&gt;In the end, it is your data and you should have a say in how it’s transmitted, kept and stored.  You also deserve a candid and plain-text description of how your data is used and what risks it might be at.  If storage or transmission of personal data is not critical to the function of the product, it should be seen as a liability and avoided at all cost.  When it comes to machine learning of personal behaviors and the granularity in which it’s able to be tracked, this sentiment is only heightened.&lt;/p&gt;</content><author><name></name></author><category term="general" /><category term="home automation" /><category term="privacy" /><summary type="html">A big reason I build SwitchBoard is so I can do things the way I think they should be done. I like having my data be within my walls as much as possible. For external APIs, you often have little choice in rely on those outside data points, but if they’re varied, you at least lessen your exposure. My personal setup consumes a decent number of APIs and no single one has any real useful bits - they’re tied together and the logic to act upon them remains within my network. Maybe I’m paranoid, but that seems like a good default starting place when building something that deals with so much personal information.</summary></entry></feed>